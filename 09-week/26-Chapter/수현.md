# 26장 - ES6 함수의 추가 기능

함수의 구분

ES6이전 함수는 동일한 함수라도 다양한 형태로 호출하는 것이 가능했음

```xml
var foo = function() {
	return 1;
}

// 일반적인 함수로 호출
foo();

// 생성자 함수로 호출
new foo();

// 메서드로 호출
var obj = {foo: foo};
obj.foo();
```

호출할 수 있는 함수 객체를 callable, 인스턴스를 생성할 수 있는 함수 객체 constructor, 인스턴스를 생성할 수 없는 객체를 non-constructor

ES6부터는 구분함

| ES6함수의 구분 | constructor | prototype | super | arguments |
| -------------- | ----------- | --------- | ----- | --------- |
| 일반 함수      | o           | o         | x     | o         |
| 메서드         | x           | x         | o     | o         |
| 화살표 함수    | x           | x         | x     | x         |

## 메서드

메서드 축약 표현으로 정의된 함수만을 의미

메서드는 인스턴스를 생성할 수 없는 non-constructor

인스턴스 생성할 수 없고 prototype 프로퍼티가 없고 프로퍼타입도 생성하지 않음

자신을 바인딩한 객체를 가리키는 내부 슬록 [[HomeObject]]를 갖음

super키워드를 사용할 수 있음

## 화살표 함수

기존 함수 정의 방식보다 더 간략하게 함수를 정의할 수 있음.

콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용

### 함수 정의

```xml
const multiply = (x, y) => x*y;
multiply(2,3);  // 6
```

### 매개변수 선언

```xml
const arrow = (x, y) => { ... };
```

```xml
const arrow = x => { ... };
```

```xml
const arrow = () => { ... };
```

### 함수 몸체 정의

```xml
const power = x => x ** 2;
power(2);  // 4

const power = x => {return x**2};
```

```xml
const arrow = () => const x = 1;  // syntaxError

const arrow = () => { return const x = 1 };
```

```xml
const arrow = () => { const x = 1; }
```

> **화살표 함수와 일반 함수의 차이**

1. **화살표 함수는 인스턴스를 생성할 수 없는 Non-constructor다.**
   1. 화살표 함수는 인스턴스를 생성할 수 없으므로 prototype프로퍼티가 없고 프로토타입도 생성하지 않음
2. **중복된 매개변수는 이름을 선언할 수 없다.**
   1. 일반함수는 중복된 매개변수 이름을 선언해도 에러가 발생하지 않는다.
   2. 단 strict mode에서 중복된 매개변수 이름을 선언하면 에러가 발생
3. **화살표 함수는 함수 자체의 this, arguents, super, new.target바인딩을 갖지 않는다.**

### this

화살표 함수는 다른 함수의 인수로 전달되어 콜백 함수로 사용되는 경우가 많음.

1. add 메서드를 호출한 prefixer 객체를 가리키는 this를 일단 회피시킨 후에 콜백 함수 내부에서 사용한다.
2. Array.prototype.map의 두 번째 인수로 add 메서드를 호출한 prefixer 객체를 가리키는 this를 전달한다.
3. Function.prototype.bind 메서드를 사용하여 add메서드를 호출한 prefixer 객체를 가리키는 this를 바인딩한다.

화살표 함수는 함수 자체의 this바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다. 이를 lexical this라 한다.

### super

화살표 함수는 함수 제체는 super 바인딩을 갖지 않음.

따라서 화살표 함수 내부에서 super를 참조하면 this와 마찬가지로 상위 스코프의 super를 참조함.

### argument

화살표 함수는 함수 제체는 argument 바인딩을 갖지 않음.

따라서 화살표 함수 내부에서 argument를 참조하면 this와 마찬가지로 상위 스코프의 argument를 참조함.

## React파라미터

1.  함수에 전달된 인수들의 목록을 배열로 전달받는다.
2.  일반 매개변수와 rest 파라미터는 함께 사용할 수 있다.
3.  rest 파라미터는 반드시 마지막 파라미터여야 한다.
4.  단 하나만 선언할 수 있다.
5.  함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length프로퍼티에 영향을 주지 않는다.

### rest 파라미터와 arguments 객체

es6에서는 rest 파라미터를 사용하여 가변인자 함수의 인수 목록을 배열로 직접 전달받을 수 있다. 이를 통해 유사 배열 객체인 arguments객체를 배열로 변환하는 번거로움을 피할 수 있다.

주의) 화살표 함수는 arguments객체를 갖지 않기 때문에 화살표함수로 가변인자를 구현할 때는 무조건 rest파라미터를 사용해야 한다.

### 매개변수 기본값

인수가 전달되지 않은 경우 매개변수의 값은 undefined다.

이를 방치한 경우 예기치 않은 결과가 발생할 수 있다.
