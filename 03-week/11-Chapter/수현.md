# 11장 - 원시 값과 객체 비교

원시 타입과 객체 타입이 다른 이유

1. 원시 타입은 변경 불가능한 값 / 객체(참조) 타입의 값, 객체는 변경 가능한 값
2. 원시 값을 변수에 할당하면 변수에는 실제 값이 저장 / 객체는 변수에 할당하면 변수에는 참조 값이 저장
3. 원시 값을 갖는 변수를 다른 변수에 할당하면 원시 값이 복사되어 전달 **(값에 의한 전달)** / 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달 **(참조에 의한 전달)**

원시 값을 변경할 수 없다

→ 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름, 값은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과

즉 변경 불가능하다는 것은 변수가 아니라 값.

변수는 언제든지 재할당 통해 변수의 값을 교체할 수 있음

그에 반해 상수는 재할당이 금지된 변수

const 키워드를 사용해 선언한 변수에 할당한 객체는 변경 가능

> **원시의 값을 할당한 변수에 새로운 원시 값을 재할당 하면 재할당 이전의 원시의 값을 변경하는 것이 아니라 새로운 원시의 값을 가리키고 변수가 참조하던 메모리 공간의 주소가 바뀜**
> 이러한 값의 특성을 **불변성(immutability)
> 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없음**

### 문자열과 불변성

자바스크립트에서 문자열은 원시 타입이며, 변경 불가능=문자열이 생성된 이후에 값을 변경할 수 없음을 의미

문자열은 유사 배열 객체이므로 배열과 유사하게 접근 가능

- 인덱스로 접근 가능
- length 프로퍼티를 가짐
- 하지만 기존 값 변경은 불가능
- 새로운 문자열을 재할당 하는 것은 가능함

```xml
var str = "study";
str[0] = S;
console.log(str);  // study
```

### 값에 의한 전달 (사실은 메모리 주소 전달)

```xml
var score = 80;
var copy = score;
console.log(score);  // 80
console.log(copy);  // 80

score = 90;
console.log(score);  // 90
console.log(copy);  // 90
```

2가지 평가 방식

- 새로운 원시 값 80을 생성해서 메모리 주소를 전달하는 방식 - 이건 두 변수의 메모리 주소가 다름
  변수에 변수를 할당했을때 변수에 있는 값이 전달 됨
  그것이 **값에 의한 전달**이라고 할 수 있음
  하지만 둘이 같은 값이냐라고 물었을때는 아님 다른 메모리 공간에 저장된 별개의 값임
- score의 변수값 80의 메모리 주소로 전달하는 방식 - 이건 두 변수의 메모리 주소가 같음
  원시 값을 참조하다가 어느 한쪽이 새로운 재할당이 발생했을때 비로소 새로운 메모리 공간에 재할당된 값을 저장하도록 동작함

⇒ 두가지 방식 모두 두 변수의 원시 값은 서로 다른 메모리에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없음

## 객체

### 자바스크립트의 객체 관리 방식

자바, c++ 같은 클래스 기반 객체지향 프로그래밍 언어는 사전에 정의된 클래스를 기반으로 객체를 생성

객체 생성된 이후에는 프로퍼티를 삭제, 추가가 불가능

그에 반해 **자바스크립트는 클래스 없이 객체 생성 가능/ 이후에도 동적으로 추가, 삭제도 가능**

사용하기는 편하지만 성능 측면에서는 비효율적 방식임

그래서 v8부터는 동적탐색, 히든 클래스 방식을 사용하여 어느정도 성능을 보장함

### 변경 가능한 값

객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값으로 접근 가능

객체가 가지고 있는 메모리 값에는 객체가 가리키는 메모리 주소가 들어있음

> 원시 값은 변경 불가능한 값이므로 변수 값을 변경하기 위해서 재할당 외에는 방법이 없음
> 하지만 객체는 변경 가능한 값이기에 재할당 없이도 객체를 직접 변경 하는 것이 가능하고 추가, 삭제도 마찬가지로 가능함

참조하고 있는 메모리 주소는 똑같기 때문에 객체가 가지고 있는 메모리 주소 값은 바뀌지 않고 이전과 동일함

**단점 : 여러개의 식별자가 하나의 객체를 공유할 수 있음**

이렇게 부르는 경우도 있음

- 깊은 복사
  - 원시의 값을 할당한 변수를 다른 변수에 할당하는 것
- 얕은 복사
  - 객체를 할당한 변수를 다른 변수에 할당하는 것

=== 일치 비교 연산자는 변수에 저장되어 있는 값을 타입 변환하지 않고 비교함

```xml
var person1 = {
	name: 'Lee'
};

var person2 = {
	name: 'Lee'
};

console.log(person1 === person2); // false
// 참조 값은 전혀 다른 값이므로 false를 반환
console.log(person1.name === person2.name); // true
// person1.name은 값으로 평가될 수 있는 표현식이기에 true
```
