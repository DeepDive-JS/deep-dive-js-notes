# 19장 프로토타입

1. 설계도

   ```jsx
   function Person() {
     this.name = name;
   }
   ```

   이 설계도는 prototype이라는 주머니를 가지고 있음

   ```jsx
   console.log(Person.prototype);
   // { constructor: ƒ Person(name), __proto__: Object.prototype }
   ```

   이 prototype이라는 주머니는 미래에 만들어질 Person의 자식인 인스턴스가 참고할 설계서이다.

1. Person.prototype은 공용 도구함

   ```jsx
   Person.prototype.sayHello = function () {
     console.log(`Hi, ${this.name}`);
   };
   ```

   이건 Person으로 만들어진 인스턴스들이 공통으로 쓸 도구함에 들어있는 sayHello라는 도구이다.

1. 인스턴스 만들기

   ```jsx
   const me = new Person("Lee");
   ```

   이때 new가 하는 일은 다음과 같다.

   1. 새 객체 { }를 하나 만든다.
   2. 그 객체의 숨은 연결고리 **proto**를 Person.prototype으로 연결한다.
   3. 함수 본문 [this.name](http://this.name) = name을 실행한다.
   4. 완성된 객체 me를 돌려준다.

   이제 결과값은

   ```jsx
   me.__proto__ -> Person.prototype -> Object.prototype
   ```

   prototype은 공용 도구함이고 **proto**는 자기 도구함을 찾는 끈이다.

   ```jsx
   Objcet.prototype
   ↑
   Function.prototype
   ↑
   Person.prototype
   ↑
   me.__proto__

   ```

## 1. 객체지향 프로그래밍 (OOP)

**핵심**: 실세계를 객체로 표현하는 프로그래밍 방식

```jsx
const person = {
  name: '홍길동',  *// 상태(프로퍼티)*
  age: 25,
  sayHello() {     *// 동작(메서드)*
    console.log(`안녕하세요, ${this.name}입니다.`);
  }
};
```

---

## 2. 왜 프로토타입이 필요한가?

### 문제: 메서드 중복 생성

```jsx
function Circle(radius) {
  this.radius = radius;
  this.getArea = function() {  *// 인스턴스마다 중복 생성!*
    return Math.PI * this.radius ** 2;
  };
}

const c1 = new Circle(1);
const c2 = new Circle(2);
console.log(c1.getArea === c2.getArea); *// false → 메모리 낭비*
```

### 해결: 프로토타입 상속

```jsx
function Circle(radius) {
  this.radius = radius;
}

Circle.prototype.getArea = function() {  *// 한 번만 생성*
  return Math.PI * this.radius ** 2;
};

const c1 = new Circle(1);
const c2 = new Circle(2);
console.log(c1.getArea === c2.getArea); *// true → 메서드 공유!*
```

**장점**: 메모리 효율 + 코드 재사용

---

## 3. 프로토타입 핵심 개념

### `__proto__` vs `prototype`

```jsx
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

*// __proto__: 모든 객체가 가짐 (자신의 프로토타입 참조)*
console.log(me.__proto__ === Person.prototype); *// true// prototype: 생성자 함수만 가짐 (인스턴스의 프로토타입 설정)*
console.log(Person.prototype); *// {constructor: ƒ}*
```

| 구분      | 소유        | 목적                       |
| --------- | ----------- | -------------------------- |
| **proto** | 모든 객체   | 자신의 프로토타입 접근     |
| prototype | 생성자 함수 | 인스턴스의 프로토타입 설정 |

**권장**: `Object.getPrototypeOf()` / `Object.setPrototypeOf()` 사용

---

## 4. 프로토타입 체인

**개념**: 프로퍼티 검색 시 상위 프로토타입을 따라 올라가며 탐색

```jsx
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

*// hasOwnProperty 탐색 과정:// me → Person.prototype → Object.prototype (발견!)*
console.log(me.hasOwnProperty('name')); *// true*
```

**체인 구조**

```
me
  ↓
Person.prototype
  ↓
Object.prototype
  ↓
null
```

---

## 5. 오버라이딩과 섀도잉

```jsx
function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function() {
  console.log(`Hi (prototype)`);
};

const me = new Person('Lee');

*// 인스턴스 메서드 추가 → 프로토타입 메서드를 가림 (섀도잉)*
me.sayHello = function() {
  console.log(`Hi (instance)`);
};

me.sayHello(); *// "Hi (instance)"*

delete me.sayHello;
me.sayHello(); *// "Hi (prototype)" - 프로토타입 메서드 복구*
```

**핵심**: 인스턴스 프로퍼티가 프로토타입 프로퍼티를 덮어쓰는 게 아니라 **가림**

---

## 6. 객체 생성 방식과 프로토타입

| 생성 방식            | 프로토타입         |
| -------------------- | ------------------ |
| {} 객체 리터럴       | Object.prototype   |
| new Object()         | Objcet.prototype   |
| new Person()         | Person.prototype   |
| Object.create(proto) | proto(명시적 지정) |
| class Person {}      | Person.prototype   |

---

## 7. 정적 vs 프로토타입 메서드

```jsx
function Person(name) {
  this.name = name;
}

*// 프로토타입 메서드: 인스턴스로 호출*
Person.prototype.sayHello = function() {
  console.log(`Hi, ${this.name}`);
};

*// 정적 메서드: 생성자 함수로 호출*
Person.staticMethod = function() {
  console.log('Static!');
};

const me = new Person('Lee');
me.sayHello();           *// OK*
Person.staticMethod();   *// OK
// me.staticMethod();    // 에러
// Person.sayHello();    // 에러*
```

**언제 정적 메서드?** → `this` 사용하지 않는 유틸리티 함수

---

## 8. 직접 상속

### `Object.create`

```jsx
const parent = {
  x: 1,
  sayX() { console.log(this.x); }
};

*// 명시적으로 프로토타입 지정*
const child = Object.create(parent);
child.y = 2;

console.log(child.x); *// 1 (상속)*
console.log(child.y); *// 2 (자신의 프로퍼티)*
```

### 객체 리터럴에서 `__proto__`

```jsx
const parent = { x: 1 };

const child = {
  __proto__: parent,  *// 프로토타입 지정*
  y: 2
};

console.log(child.x, child.y); *// 1 2*
```

---

## 9. 프로퍼티 확인과 열거

### 존재 확인

```jsx
const person = { name: 'Lee', age: 20 };

console.log('name' in person);              *// true (상속 포함)*
console.log(person.hasOwnProperty('name')); *// true (자신의 프로퍼티만)*
```

### 열거

```jsx
const person = {
  name: 'Lee',
  age: 20,
  __proto__: { x: 10 }
};

*// for...in: 상속 포함*
for (const key in person) {
  console.log(key); *// name, age, x*
}

*// Object.keys: 자신의 프로퍼티만 (권장!)*
console.log(Object.keys(person));    *// ["name", "age"]*
console.log(Object.values(person));  *// ["Lee", 20]*
console.log(Object.entries(person)); *// [["name", "Lee"], ["age", 20]]*
```
