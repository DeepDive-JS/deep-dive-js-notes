# 25장 - 클래스

클래스와 생성자 함수는 모두 프로토타입 기반으로 인스턴스를 생성하지만 완전히 같은 방식으로 동작하지는 않는다. 클래스는 문법적으로 더 엄격하고, 생성자 함수에서 제공하지 않는 기능도 포함한다.

## 클래스와 생성자 함수의 주요 차이점

1. **new 없이 호출 불가**
   - 클래스를 new 없이 호출하면 TypeError가 발생한다.
   - 반면 생성자 함수는 new 없이 호출하면 일반 함수 호출로 동작하며, this가 전역 객체 또는 undefined(엄격 모드)로 바인딩된다.
2. **상속 문법 지원 여부**
   - 클래스는 `extends`, `super` 키워드로 명확한 상속 문법을 제공한다.
   - 생성자 함수는 프로토타입을 직접 조작해야 하며 문법 레벨의 상속 지원이 없다.
3. **호이스팅 방식**
   - 클래스 선언도 호이스팅되지만 **TDZ(Temporal Dead Zone)**에 걸리므로 선언 전에 접근하면 ReferenceError가 발생한다.
   - 생성자 함수는 함수 선언문이면 함수 호이스팅, 함수 표현식이면 변수 호이스팅이 그대로 적용된다.
4. **strict mode 적용 여부**
   - 클래스 내부 코드는 자동으로 strict mode가 적용되며 해제할 수 없다.
   - 생성자 함수는 strict mode가 자동 적용되지 않는다.
5. **메서드의 [[Enumerable]] 속성**
   - 클래스 안에서 정의된 모든 메서드는 enumerable이 false며 열거되지 않는다.
   - 생성자 함수 방식은 프로토타입에 추가하는 방식에 따라 enumerable 여부를 직접 설정할 수 있다.

## 클래스 정의

`class` 키워드로 정의하며, 클래스는 표현식 형태로도 만들 수 있기 때문에 **일급 객체**다.

```jsx
class Person {}
const Person = class {}; // 익명 클래스 표현식
const Person = class MyClass {}; // 기명 클래스 표현식
```

### 일급 객체로서의 특징

- 런타임에 생성 가능
- 변수나 자료구조에 저장 가능
- 함수 인자로 전달 가능
- 함수 반환값으로 사용 가능

### 클래스 구조

클래스 몸체에는 **메서드만** 정의할 수 있다.

- constructor
- 프로토타입 메서드
- 정적 메서드

```jsx
class Person {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    console.log(`hi my name is ${this.name}`);
  }

  static sayHello() {
    console.log("hello");
  }
}
```

## 클래스 호이스팅

클래스는 평가 단계에서 함수로 변환되지만 TDZ가 적용된다.

```jsx
{
  console.log(Person); // ReferenceError
  class Person {}
}
```

## 인스턴스 생성

클래스는 반드시 `new`와 함께 호출해야 한다.

```jsx
class Person {}
const me = new Person(); // OK
Person(); // TypeError
```

클래스 표현식의 내부 이름(MyClass 등)은 외부에서 접근할 수 없다.

## 메서드

### constructor

- 인스턴스를 생성하고 초기화하는 역할.
- 명시적으로 return을 작성하면 객체를 반환하는 경우에만 동작하며, 기본적으로는 this를 반환한다.
- 클래스당 하나만 정의할 수 있다.
- 생략 시 빈 constructor가 암묵적으로 생성된다.

### 프로토타입 메서드

클래스 몸체에 정의된 메서드는 자동으로 프로토타입 메서드가 된다.

```jsx
Person.prototype.sayHi;
```

### 정적 메서드 (static)

- 인스턴스가 아닌 **클래스 자체**에 바인딩되는 메서드.
- 인스턴스로 호출할 수 없다.
- 인스턴스 프로퍼티(예: this.name)에 접근 불가.

```jsx
Person.sayHello();
```

### 정적 vs 프로토타입 메서드 차이

1. 프로토타입 체인 위치가 다르다.
2. 호출 주체가 다르다 (클래스 vs 인스턴스).
3. 정적 메서드는 인스턴스를 모르므로 인스턴스 프로퍼티를 참조하지 못한다.

## 클래스의 메서드 특징

1. function 키워드 생략한 축약 표현.
2. 메서드 사이에 콤마 필요 없음.
3. 자동 strict mode.
4. enumerable이 false.
5. 내부 메서드는 constructor가 아니므로 new로 호출할 수 없다.

## 인스턴스 생성 과정

1. **빈 객체 생성 & this 바인딩**

   클래스가 호출되면 내부적으로 인스턴스용 빈 객체를 만들고 this에 바인딩한다.

2. **constructor 실행**

   this에 프로퍼티를 추가하는 초기화 과정.

3. **this 반환**

   명시적 반환이 없다면 this가 자동 반환된다.

## 프로퍼티

### 인스턴스 프로퍼티

무조건 constructor에서 this에 직접 추가해야 한다.

### 접근자 프로퍼티 (getter/setter)

- 실제 값을 가지지 않고 프로퍼티 접근/할당 시 내부 로직을 실행하는 방식.
- 호출이 아닌 "프로퍼티처럼 사용"한다.

```jsx
get name() { ... }
set name(value) { ... }
```

getter/setter 역시 프로토타입에 위치한다.

## 클래스 필드 제안

ES2022 이후 클래스 몸체에 **필드를 직접 정의**할 수 있다.

```jsx
class Person {
  name = "Unknown"; // 인스턴스 필드
}
```

### private 필드

`#`을 붙여 선언하며 클래스 내부에서만 접근 가능.

```jsx
class Person {
  #age = 20;
}
```

### static 필드

클래스에 직접 바인딩되는 정적 프로퍼티.

```jsx
class Person {
  static count = 0;
}
```

## 상속에 의한 클래스 확장

클래스 상속은 기존 클래스를 기반으로 확장하는 기법으로, 재사용성과 구조적 분리가 쉬워진다.

### extends

수퍼클래스를 기반으로 새로운 클래스를 정의한다.

### super

- super() → 수퍼클래스 constructor 호출
- super.method() → 수퍼클래스 메서드 호출

### 주의사항

1. 서브클래스에서 constructor를 정의했다면 반드시 super()를 호출해야 한다.
2. super() 호출 전에는 this를 사용할 수 없다.
3. super()는 서브클래스 constructor에서만 사용 가능하다.

## 상속 클래스의 인스턴스 생성 과정

1. 서브클래스 constructor 진입 → super() 호출
2. 수퍼클래스의 인스턴스 생성
3. 수퍼클래스 초기화
4. 서브클래스로 돌아와 this 재바인딩
5. 서브클래스 초기화
6. 완성된 인스턴스 반환

## 표준 빌트인 객체 확장

String, Number, Array 등도 생성자 함수이므로 `extends`로 확장할 수 있다.

```jsx
class MyArray extends Array {
  customMethod() {}
}
```

단, Array는 length 등의 내부 동작이 특별하므로 상속 시 동작을 주의해서 확인해야 한다.
