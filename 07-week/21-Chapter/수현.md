# 21장 - 빌트인 객체

자바스크립트의 객체 종류 3가지 간단 정리

- 표준 빌트인 객체
  - ESMAScript 사양에 정의된 객체
  - 자바스크립트의 실행환경에 관계없이 사용가능하며 전역변수처럼 언제나 참조 가능
- 호스트 객체
  - ESMAScript 사양에 정의되지 않지만 자바스크립트 실행환경에서 추가로 제공하는 객체
  - 브라우저 환경에서는 클라이언트 사이드 Web API를 호스트 객체로 제공 , node.js환경에서는 node.js고유의 api를 호스트객체로 제공
- 사용자 정의 객체
  사용자가 직접 정의한 객체

## 표준 빌트인 객체

Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체 ⇒ 프로토타입 메서드와 정적 메서드 제공함

생성자 함수 객체가 아닌 나머지 표준 빌트인 객체는 정적 메서드만 제공함

```xml
예시) String, Number, Boolean, Function ... 등은 생성자 함수로 호출하여 인스턴스를 생성할 수 있음
```

### 원시값이 있는데 String, Boolean, Number등 표준 빌트인 객체가 존재하는 이유가 무엇일까?

원시값이지만 객체처럼 동작한다. → 객체처럼 접근하면 생성되는 임시 객체를 **래퍼객체**라고 한다.

래퍼객체가 처리가 종료되면 식별자가 원시값으로 되돌리고 래퍼객체는 가비지 컬렉터 대상이 된다.

```xml
const str = "hello";
str.name = 'Lee';
console.log(str.name);  // undefined
```

문자열, 숫자, 불리언, 심벌 이외의 원시값, 즉 null, undefined는 래퍼객체를 생성하지 않는다. ⇒ null, undefined값을 객체처럼 사용하면 에러가 발생한다.

## 전역 객체

코드가 실행되기 이전 단계부터 어떤 객체보다 제일 먼저 생성되는 특수한 객체로 어떤 객체에도 속하지 않은 최상위 객체이다.

> 특징

- 전역 객체는 개발자가 의도적으로 생성할 수 없다. 즉 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않는다.
- 전역 객체의 프로퍼티를 참조할때 window를 생략할 수 있다.
- 전역 객체는 Object, String, Boolean, Number 등 과 같은 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.
- 브라우저 환경에서는 클라이언트 사이드 Web API를 호스트 객체로 제공 , node.js환경에서는 node.js고유의 api를 호스트객체로 제공한다.
- var로 선언한 전역변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역, 그리고 전역함수는 전역 객체의 프로퍼티가 된다.
  ```xml
  var foo = 1;
  console.log(window.foo);  // 1

  bar = 2;  // 선언하지 않은 변수
  console.log(window.bar);  // 2

  function bax() {return 3;}  // 전역함수
  console.log(bax());  // 3
  ```
- let, const 로 선언한 키워드는 전역객체가 아니다.
- 브라우저 환경의 모든 자바스크립트 코드는 전역 객체인 window를 공유한다. 이는 분리되어 있는 자바스크립트 코드가 하나의 전역을 공유한다는 의미이다.

## 빌트인 전역 프로퍼티

= 전역 객체의 프로퍼티 (주로 애플리케이션 전역에서 사용하는 값을 제공)

**Infinity**

무한대를 나타내는 숫자값을 가짐

**NaN**

숫자가 아님을 나타내는 값인 NaN을 가짐

### 빌트인 전역 함수

애플리케이션 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메서드이다.

**eval**

- 자바스크립트 코드를 나타내는 문자열을 인수로 전달 받음
- 전달 받은 문자열 코드가 표현식이라면 문자열 코드를 런타임에 평가하여 값을 생성 / 전달받은 인수가 표현식이 아닌 문이라면 문자열 코드를 런타임에 실행 / 문자열 코드가 여러 개의 문으로 이루어져 있다면 모든 문을 실행
- 자신이 호출된 위치에 해당하는 기존의 스코프를 런타임에 동적으로 수정함
- strict mode에서 eval의 사용은 기존의 스코프를 수정하지 않고 eval 자신의 자체적인 스코프를 생성

```xml
const x = 1;

function foo(){
	'use strict'
	eval('var x = 2; console.log(x););  // 2
	console.log(x); // 1;
}
```

- 인수로 전달받은 문자열 코드가 Let, const키워드를 사용한 변수선언문이라면 암묵적으로 strict mode로 실행됨

```xml
const x = 1;

function foo(){
	eval('var x = 2; console.log(x););  // 2
	eval('const x = 3; console.log(x););  // 3
	console.log(x); // 2;
}

foo();
console.log(x);  1
```

- eval함수를 통해 사용자로 받은 입력 콘텐츠를 실행하는 것은 보안에 매우 취약함. eval함수를 통해 실행되는 코드는 자바스크립트 엔진에 의해 최적화가 수행되지 않으므로 일반적인 코드 실행에 비해 처리속도가 느림. 따라서 **eval 함수의 사용은 금지해야 함.**

**isFinite**

전달받은 인수가 정상적인 유한수인지 검사하여 유한수이면 true를 반환, 무한수이면 false를 반환.

전달받은 인수의 타입이 숫자가 아닌 경우 숫자로 타입을 변환한 후 검사를 수행함. 이때 인수가 NaN으로 평가되는 값이면 false를 반환함.

```xml
isFinite(0);  // true
isFinite('10'); // true
isFinite(Infinity); // false
isFinite(NaN); // false
isFinite('Hello') // false
```

**isNaN**

전달받은 인수가 NaN인지 검사하여 그 결과를 불리언 타입으로 반환, 전달받은 인수의 타입이 숫자가 아닌 경우 숫자로 타입을 반환한 후 검사를 수행.

```xml
isNaN(NaN); // true
isNaN(10); // false

isNaN('hello'); // true
isNaN(''); // false
isNaN('10'); // false

isNaN(true); // false
isNaN(false); // false

isNaN(undefined); // true
isNaN({}); // true

isNaN(new Date()); // false
isNaN(new Date().toString()); // true
```

**parseFloat**

전달받은 문자열 인수를 부동 소수점 숫자, 즉 실수로 해석하여 반환함

```xml
parseFloat('3.14');  // 3.14
parseFloat('10.00');  // 10

parseFloat('10 34 24');  // 10
parseFloat('40 years');  // 40
parseFloat('he was 40');  // NaN 첫번째 문자열을 숫자로 반환 불가면 NaN반환
parseFloat(' 60 ');  // 60 앞뒤 공백 무시
```

**parseInt**

전달받은 문자열을 정수로 해석하여 반환함

두번째 인수로 진법을 나타내는 기수를 전달할 수 있음 (2진법/8진법/16진법…)

```xml
parseInt('10', 2); // 2
//10을 2진수로 해석하고 그 결과를 10진수 정수로 반환
```

기수를 지정하여 10진수 숫자를 해당 기수의 문자열로 반환하여 반환하고 싶을때는 Number.prototype.toString메서드 사용

```xml
const x = 15;
x.toString(2);  // '1111'
```

두 번째로 진법을 나타내는 기수를 지정하지 않더라도 첫 번째 인수로 전달된 문자열이 “0x”또는 “0X”로 시작하는 16진수 리터럴이라면 16진수로 해석하여 10진수 정수로 반환함

```xml
parseInput('0xf'); // 15
```

첫 번째 인수로 전달한 문자열의 첫 번째 문자가 해당 지수의 숫자로 변환될 수 없다면 NaN을 반환

```xml
parseInt('A0'); // NaN
```

첫 번째 인수로 전달한 문자열의 두 번째 문자부터 해당 진수를 나타내는 숫자가 아닌 문자와 마주치면 이 문자와 계속되는 문자들은 전부 무시되며 해석된 정수값만 반환함

첫 번째 인수로 전달한 문자열에 공백이 있다면 첫 번째 문자열만 해석하여 앞뒤 공백은 무시됨, 만약 첫 번째 문자열을 숫자로 해석할 수 없는 경우 NaN을 반환함

**encodeURI / decodeURI**

- encodeURI함수는 완전한 URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩 함.
- decodeURI함수는 인코딩된 URI를 전달받아 이스케이프 처리 이전으로 디코딩 함.

encodeURIComponent/ decodeURIComponent

- encodeURIComponent함수는 URI구성요소를 인수로 전달받아 인코딩 함. (알파벳, 0~9의 숫자, -\_.!~\*’()문자는 이스케이프 처리에서 제외)
